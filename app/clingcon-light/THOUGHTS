What is the exact relation between grounding atoms/literals and solver literals (n to 1 I assume)

- shouldn't I always use solver literals ?
- how to create new ASPIF rules (backend) with solver literals?
- I assume that grounding atoms/literals and solver literals share the same DataType but are actually different
- use C++ API clingo.hh
- Domains:
  Should I still use domains with holes
   Holes:
   - can represent (x=2y) without constraints (needs buggy equality processing)
   - can represent small domains and is needed for some initial propagation using facts
   No Holes:
   - faster lookup, no binary search, easier implementation
  FAZIT: Use old classes with Holes, afterwards compare with optimized version without holes.
- think about faster propagation, saving current lower/upper bound and only add changes
- think about linear constraints with conditions!
- createOrderClauses, currently i can translate contraints but do not create order clauses,
  this is still done with propagator
- replace ~l with -l, otherwise we do bitwise inverse on literals instead of negation

First I need to do grounding.
Than I can access the backend, to modify the ground program.
I can access the theoryAtoms via Clingo::Control::theory_atoms()
Then I need to modify the program/do completion, add new theory atoms via the backend.
I have to do this outside the propagator (at least not during the init call)


What about solver_literal from PropagateInit
All datastructures are created using aspif literals,
    on init I have to convert all of them to solver_literals


    Printing:
    Currently outside of propagator on solve() method,
    no functionality like json

Facts: Simple facts like domain predicates can not be detected as true,
  as the grounder does not have any feature like this. So &dom{0..1} = x. can not be detected
  and an unbounded variable is created.
  is_fact is only an approximation and only available for symbolic atoms, theory atoms excluded.


Flaws with combining propagators. Can not create variables that may be necessary for another propagator.


Missing isTrue etc... in PropagateInit function

Einfache Trennung zwischen Propagator und MultiShot Fähigkeiten.
Also clingcon/clingoDL über python API steuern als wäre es clingo,
nur das intern schon ein Propagator registriert wurde

Output Bahviour Intern machen, so das extra ausgaben vom python script extra requested werden können,
bzw. das die Ausgabe nicht über check erfolgt, sondern in onModel

TODO:
 - optimization (minimization/maximization)
 - make #include <csp> optional, only add if not already loaded if possible 
 - make strict/non-strict available via &sum(non-strict){} constructs

How to use python interface with C++ propagator. General design problem.

Current Call:
cmake -H. -Bbuild/debug -DCLINGO_INCLUDE_DIR=/home/ostrowsk/work/git/clingofiles/include -DCLINGO_LIBRARY_DIR=/home/ostrowsk/work/git/clingofiles/lib -DCMAKE_BUILD_TYPE=Debug  -DCLINGCON_BUILD_TESTS=True
or
cmake -H. -Bbuild -DCLINGO_INCLUDE_DIR=/home/wv/opt/clingo-banane/include -DCLINGO_LIBRARY_DIR=/home/wv/opt/clingo-banane/lib


Use Cases:
  In all use cases clingcon should be replaceable with clingoDL/clingoLP/clingo or any other cpp written derivate.
  Python should be replaceable with Lua.
  1. clingcon as binary for logic programs
  2. clingcon as binary for logic programs with python main function.
  3. Python program that includes clingcon library that has the clingcon propagator (and initialization of it) already added.

Feature Requests:

  *** Printing Theory Models
  **  UseCases
    - be able to use json output with theory output information
    - a propagagor adds additional information (e.g. variable/value pairs) for each model
    - having an interface-function to print a model (with the additional information) in the predefinied (clasp,json,aspcomp) way
    - be able to access additional information (e.g. variable/value pairs) in the on_model function
  **  Propositions
    - There already exists a Clasp::OutputTable::Theory class.
      Also Clingo::Control has a virtual void addToModel(const Clasp::Model& m, bool complement, Gringo::SymVec& ret) function.
      So add a virtual addToModel function to the Clasp::Propagator class
      class Propagator {
      public:
            ...
            virtual void addToModel(const Clasp::Model& m, bool complement, Gringo::SymVec& ret) {}
            ...
      };
      This function should be called for every propagator in the ClingoModel::atoms function (instead for the ClingoControl object).
      In this way, each propagator (for each thread) can add additional information ( (newly created) gringo symbols) to each model.
      This output should automatically be correctly displayed in any output format (json, etc...).
      In the on_model() function, this information can be accessed and/or printed.

  *** Printing Statistics
  **  UseCases
    - add additional statistics of the propagator in a well formatted way to the normal statistic information.

  *** Dynamically loading C/C++ propagators in python code
  **  UseCases
    - having libraries for different propagators like csp, dl[int], dl[real], etc..
    - dynamically load these libraries and automatically add their propagators (including additional initialization)
  **  Propositions
      Dynamically load a propagator in python.
      Registering the propagator and initialization is completely handled in the library.

      #script (python)

      import ctypes
      import clingo
      
      def main(prg):
              %clingcon = ctypes.windll.clingcon
              clingcon = ctypes.cdll.LoadLibrary('clingcon.so')
              clingcon.load(prg)
              prg.ground([("base", [])])
              prg.solve()
      #end.

      TODO: Add a load function to clingo[DL].
      
      
  * Combining fixed propagators with reactive solving with the python interface
    - be able to include clingcon python library instead of clingo
    - be able to write an encoding with a python main method and use clingcon binaries to run it
      - the respective propagators have to be already registered within clingcon
      - the propagators need an interface method pre/postGround() to be able to add static rules, minimize statements, etc.. to the grounder
      - we may need a method to execute the python main() function inside the ClingoApplication::main()
        - this method should not be called from within the python main() function, as it wiill result in an endless loop

  * Preprocessor
    - ability to run the clasp preprocessing system manually in the init(), postGround() function of a propagator
    - access the current truth value (true, false, unknown) at every accessible step (preGround, postGround, init, propagate, check, undo)

  * Interface changes
    - init call for all threads at once or once for all threads
      - what happens in the multi-shot context, is init only called once ?
        Do we need a reInit() function with all new information that is called for every additional solve call ?
    - maybe merge PropagateInit and PropagateControl,
      - assignment(), add_literal(), has_watch(), add_watch(), remove_watch(), add_clause(), propagate(), thread_id()
        could work for both transparently, on init adding static knowledge, on propagate/check adding dynamic knowledge
      - adding literals and watches to the solver:
        - should be available during the init call
        - should be possible to add from any solver thread for any solver thread
