What is the exact relation between grounding atoms/literals and solver literals (n to 1 I assume)

- shouldn't I always use solver literals ?
- how to create new ASPIF rules (backend) with solver literals?
- I assume that grounding atoms/literals and solver literals share the same DataType but are actually different
- use C++ API clingo.hh
- Domains:
  Should I still use domains with holes
   Holes:
   - can represent (x=2y) without constraints (needs buggy equality processing)
   - can represent small domains and is needed for some initial propagation using facts
   No Holes:
   - faster lookup, no binary search, easier implementation
  FAZIT: Use old classes with Holes, afterwards compare with optimized version without holes.
- think about faster propagation, saving current lower/upper bound and only add changes
- think about linear constraints with conditions!
- createOrderClauses, currently i can translate contraints but do not create order clauses,
  this is still done with propagator
- replace ~l with -l, otherwise we do bitwise inverse on literals instead of negation

First I need to do grounding.
Than I can access the backend, to modify the ground program.
I can access the theoryAtoms via Clingo::Control::theory_atoms()
Then I need to modify the program/do completion, add new theory atoms via the backend.
I have to do this outside the propagator (at least not during the init call)


What about solver_literal from PropagateInit


Current Call:
cmake -H. -Bbuild/debug -DCLINGO_INCLUDE_DIR=/home/ostrowsk/work/git/clingofiles/include -DCLINGO_LIBRARY_DIR=/home/ostrowsk/work/git/clingofiles/lib -DCMAKE_BUILD_TYPE=Debug
or
cmake -H. -Bbuild -DCLINGO_INCLUDE_DIR=/home/wv/opt/clingo-banane/include -DCLINGO_LIBRARY_DIR=/home/wv/opt/clingo-banane/lib



I have a problem creating an interleaving propagator.
This would basically mean two proapgators prop1 and prop2.
prop2 can call control.propagate() to get the new information to the solver
and do unit propagation on it during its propagation and then continue with the new information.

First Question:
How do i get this information back without first propagating to a fixpoint?
So do i have to process my changes list first before i get the new information?
If this is the case, I'm restricted in the order of propagation.

First Problem:
My prop2 may add new variables (control.add_literal()) to the solver thread, and prop1 needs to watch them.
Currently I can't figure out how to do this, as I'm doing propagation with prop2,
and I guess that there exists some kind of state that then maps all new watches to this propagator.

Supposed Solution:
I only have one big propagator and try to do the interleaving myself.
The problem that arises with this approach is that control.propagate() no longer does the propagation
that prop1 formerly did.
After calling control.propagate() I do not know the literals that became true during this call (and that i actually watch).

Did I overlooked anything? Can I use the assignment() from the control
to get an idea of what unit propagation added? Is this the right way to do it?
I will get called a second time with literals that I already processed if I do it this way.
