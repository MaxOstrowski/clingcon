What is the exact relation between grounding atoms/literals and solver literals (n to 1 I assume)

- shouldn't I always use solver literals ?
- how to create new ASPIF rules (backend) with solver literals?
- I assume that grounding atoms/literals and solver literals share the same DataType but are actually different
- use C++ API clingo.hh
- Domains:
  Should I still use domains with holes
   Holes:
   - can represent (x=2y) without constraints (needs buggy equality processing)
   - can represent small domains and is needed for some initial propagation using facts
   No Holes:
   - faster lookup, no binary search, easier implementation
  FAZIT: Use old classes with Holes, afterwards compare with optimized version without holes.
- think about faster propagation, saving current lower/upper bound and only add changes
- think about linear constraints with conditions!
- createOrderClauses, currently i can translate contraints but do not create order clauses,
  this is still done with propagator
- replace ~l with -l, otherwise we do bitwise inverse on literals instead of negation

First I need to do grounding.
Than I can access the backend, to modify the ground program.
I can access the theoryAtoms via Clingo::Control::theory_atoms()
Then I need to modify the program/do completion, add new theory atoms via the backend.
I have to do this outside the propagator (at least not during the init call)


What about solver_literal from PropagateInit
All datastructures are created using aspif literals,
    on init I have to convert all of them to solver_literals


    Printing:
    Currently outside of propagator on solve() method,
    no functionality like json

Facts: Simple facts like domain predicates can not be detected as true,
  as the grounder does not have any feature like this. So &dom{0..1} = x. can not be detected
  and an unbounded variable is created.
  is_fact is only an approximation and only available for symbolic atoms, theory atoms excluded.


Flaws with combining propagators. Can not create variables that may be necessary for another propagator.


Missing isTrue etc... in PropagateInit function

Einfache Trennung zwischen Propagator und MultiShot Fähigkeiten.
Also clingcon/clingoDL über python API steuern als wäre es clingo,
nur das intern schon ein Propagator registriert wurde

Output Bahviour Intern machen, so das extra ausgaben vom python script extra requested werden können,
bzw. das die Ausgabe nicht über check erfolgt, sondern in onModel

TODO:
 - optimization (minimization/maximization)
 - make #include <csp> optional, only add if not already loaded if possible 
 - make strict/non-strict available via &sum(non-strict){} constructs

How to use python interface with C++ propagator. General design problem.

Current Call:
cmake -H. -Bbuild/debug -DCLINGO_INCLUDE_DIR=/home/ostrowsk/work/git/clingofiles/include -DCLINGO_LIBRARY_DIR=/home/ostrowsk/work/git/clingofiles/lib -DCMAKE_BUILD_TYPE=Debug  -DCLINGCON_BUILD_TESTS=True
or
cmake -H. -Bbuild -DCLINGO_INCLUDE_DIR=/home/wv/opt/clingo-banane/include -DCLINGO_LIBRARY_DIR=/home/wv/opt/clingo-banane/lib


Use Cases:
  In all use cases clingcon should be replaceable with clingoDL/clingoLP/clingo or any other cpp written derivate.
  Python should be replaceable with Lua.
  1. clingcon as binary for logic programs
  2. clingcon as binary for logic programs with python main function.
  3. Python program that includes clingcon library that has the clingcon propagator (and initialization of it) already added.

Feature Requests:

  * Printing
    - be able to use json output
      - add additional information (e.g. variable/value pairs) for each model
      - having an interface-function to print a model (with the additional information) in the predefinied (clasp,json,aspcomp) way
    - be able to access additional information (e.g. variable/value pairs) in the on_model function
    - be able to correctly add statistics to the clingo statistics output

  * Combining fixed propagators with reactive solving with the python interface
    - be able to include clingcon python library instead of clingo
    - be able to write an encoding with a python main method and use clingcon binaries to run it
      - the respective propagators have to be already registered within clingcon
      - the propagators need an interface method pre/postGround() to be able to add static rules, minimize statements, etc.. to the grounder
      - we may need a method to execute the python main() function inside the ClingoApplication::main()
        - this method should not be called from within the python main() function, as it wiill result in an endless loop

  * Preprocessor
    - ability to run the clasp preprocessing system manually in the init(), postGround() function of a propagator
    - access the current truth value (true, false, unknown) at every accessible step (preGround, postGround, init, propagate, check, undo)

  * Interface changes
    - init call for all threads at once or once for all threads
      - what happens in the multi-shot context, is init only called once ?
        Do we need a reInit() function with all new information that is called for every additional solve call ?
    - maybe merge PropagateInit and PropagateControl,
      - assignment(), add_literal(), has_watch(), add_watch(), remove_watch(), add_clause(), propagate(), thread_id()
        could work for both transparently, on init adding static knowledge, on propagate/check adding dynamic knowledge
      - adding literals and watches to the solver:
        - should be available during the init call
        - should be possible to add from any solver thread for any solver thread
