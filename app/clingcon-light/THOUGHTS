What is the exact relation between grounding atoms/literals and solver literals (n to 1 I assume)

- shouldn't I always use solver literals ?
- how to create new ASPIF rules (backend) with solver literals?
- I assume that grounding atoms/literals and solver literals share the same DataType but are actually different
- use C++ API clingo.hh
- Domains:
  Should I still use domains with holes
   Holes:
   - can represent (x=2y) without constraints (needs buggy equality processing)
   - can represent small domains and is needed for some initial propagation using facts
   No Holes:
   - faster lookup, no binary search, easier implementation
  FAZIT: Use old classes with Holes, afterwards compare with optimized version without holes.
- think about faster propagation, saving current lower/upper bound and only add changes
- think about linear constraints with conditions!

First I need to do grounding.
Than I can access the backend, to modify the ground program.
I can access the theoryAtoms via Clingo::Control::theory_atoms()
Then I need to modify the program/do completion, add new theory atoms via the backend.
I have to do this outside the propagator (at least not during the init call)


Current Call:
cmake -H. -Bbuild -DCLINGO_INCLUDE_DIR=/home/ostrowsk/work/git/clingofiles/include -DCLINGO_LIBRARY_DIR=/home/ostrowsk/work/git/clingofiles/lib
or
cmake -H. -Bbuild -DCLINGO_INCLUDE_DIR=/home/wv/opt/clingo-banane/include -DCLINGO_LIBRARY_DIR=/home/wv/opt/clingo-banane/lib



Functions possibly subject to remove:
VariableCreator::constrainUpper/LowerBound
